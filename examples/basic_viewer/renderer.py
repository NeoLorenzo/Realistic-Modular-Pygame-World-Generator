# world_generator/renderer.py

"""
================================================================================
PYGAME WORLD RENDERER
================================================================================
This module provides a class to render the world data generated by the
WorldGenerator onto a Pygame surface.

Data Contract:
---------------
- Inputs (on initialization):
    - generator (WorldGenerator): An initialized WorldGenerator instance.
    - config (dict): A dictionary of simulation parameters.
    - logger: A configured Python logging object.
- Inputs (on draw call):
    - screen (pygame.Surface): The target surface to draw on.
    - camera (Camera): An object that handles view transformations.
- Outputs: None.
- Side Effects: Draws pixels to the provided Pygame surface.
- Invariants: The visual output is a deterministic function of the generator's
  data and the camera's state.
================================================================================
"""

import pygame
import logging

# We use a type hint for the generator without creating a circular import
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from world_generator.generator import WorldGenerator

import numpy as np
from world_generator import config as DEFAULTS

# --- Default Color Mappings ---
# These are used by the renderer if no other color map is provided.
# Format: (R, G, B)
COLOR_MAP_TERRAIN = {
    "deep_water": (0, 0, 50),
    "shallow_water": (26, 102, 255),
    "sand": (240, 230, 140),
    "grass": (34, 139, 34),
    "dirt": (139, 69, 19),
    "mountain": (112, 128, 144)
}

COLOR_MAP_TEMPERATURE = {
    "coldest": (0, 0, 100),
    "cold": (0, 0, 255),
    "temperate": (255, 255, 0),
    "hot": (255, 0, 0),
    "hottest": (150, 0, 0)
}

COLOR_MAP_HUMIDITY = {
    "dry": (210, 180, 140),
    "wet": (70, 130, 180)
}


import threading
import queue

class WorldRenderer:
    """
    Handles the visualization of the world data on a Pygame screen.
    """
    def __init__(self, generator: 'WorldGenerator', logger: logging.Logger):
        """
        Initializes the renderer.
        """
        self.generator = generator
        self.logger = logger
        self.logger.info("WorldRenderer initializing...")

        # Load settings directly from the generator instance
        self.chunk_size = self.generator.settings['chunk_size_cm']
        self.chunk_resolution = DEFAULTS.CHUNK_RESOLUTION
        
        # Load all level and color data
        self.terrain_levels = DEFAULTS.TERRAIN_LEVELS
        self.temp_levels = DEFAULTS.TEMP_LEVELS
        self.color_maps = {
            "terrain": COLOR_MAP_TERRAIN,
            "temperature": COLOR_MAP_TEMPERATURE,
            "humidity": COLOR_MAP_HUMIDITY
        }
        
        # A multi-level cache for different view modes
        self.chunk_surface_cache = {
            "terrain": {},
            "temperature": {},
            "humidity": {}
        }
        self.placeholder_cache = {
            "terrain": {},
            "temperature": {},
            "humidity": {}
        }
        self.placeholder_resolution = DEFAULTS.PLACEHOLDER_RESOLUTION
        
        # --- Scaled Surface Cache for Memoization (Rule 8 & 11) ---
        self.scaled_surface_cache = {}
        self._last_camera_zoom = -1.0 # Used to detect zoom changes
        self._last_view_mode = None   # Used to detect view mode changes
        
        # --- Asynchronous Generation Setup (Rule 8) ---
        self.generation_request_queue = queue.Queue()
        self.generation_result_queue = queue.Queue()
        self.stop_event = threading.Event()
        self.worker_thread = threading.Thread(target=self._chunk_generator_worker)
        self.worker_thread.daemon = True
        self.worker_thread.start()
        self.pending_requests = set()
        
        # --- Color Lookup Table (LUT) Generation (Rule 11) ---
        # Pre-calculate color gradients to replace expensive per-pixel math.
        self._color_luts = {
            "temperature": self._create_temperature_lut(),
            "humidity": self._create_humidity_lut()
        }

        self.logger.info("WorldRenderer initialized with background worker and color LUTs.")

    def _create_temperature_lut(self) -> np.ndarray:
        """Creates a 256-entry color LUT for the temperature map."""
        # Create an array of 256 values from 0.0 to 1.0
        t = np.linspace(0.0, 1.0, 256)[..., np.newaxis]
        color_map = self.color_maps["temperature"]
        
        # Apply the same np.select logic as before, but only once on the 256 values
        colors = np.select(
            [t < self.temp_levels["cold"], t < self.temp_levels["temperate"], t < self.temp_levels["hot"]],
            [
                (1 - t/self.temp_levels["cold"]) * np.array(color_map["coldest"]) + (t/self.temp_levels["cold"]) * np.array(color_map["cold"]),
                (1 - (t-self.temp_levels["cold"])/(self.temp_levels["temperate"]-self.temp_levels["cold"])) * np.array(color_map["cold"]) + ((t-self.temp_levels["cold"])/(self.temp_levels["temperate"]-self.temp_levels["cold"])) * np.array(color_map["temperate"]),
                (1 - (t-self.temp_levels["temperate"])/(self.temp_levels["hot"]-self.temp_levels["temperate"])) * np.array(color_map["temperate"]) + ((t-self.temp_levels["temperate"])/(self.temp_levels["hot"]-self.temp_levels["temperate"])) * np.array(color_map["hot"])
            ],
            default=(1 - (t-self.temp_levels["hot"])/(1.0-self.temp_levels["hot"])) * np.array(color_map["hot"]) + ((t-self.temp_levels["hot"])/(1.0-self.temp_levels["hot"])) * np.array(color_map["hottest"])
        )
        return colors.astype(np.uint8)

    def _create_humidity_lut(self) -> np.ndarray:
        """Creates a 256-entry color LUT for the humidity map."""
        t = np.linspace(0.0, 1.0, 256)[..., np.newaxis]
        color_map = self.color_maps["humidity"]
        colors = (1 - t) * np.array(color_map["dry"]) + t * np.array(color_map["wet"])
        return colors.astype(np.uint8)

    def _get_terrain_color_array(self, elevation_values: np.ndarray) -> np.ndarray:
        """Converts an array of elevation data into an RGB color array."""
        colors = np.zeros((*elevation_values.shape, 3), dtype=np.uint8)
        color_map = self.color_maps["terrain"]
        
        water_mask = elevation_values < self.terrain_levels["water"]
        sand_mask = (elevation_values >= self.terrain_levels["water"]) & (elevation_values < self.terrain_levels["sand"])
        grass_mask = (elevation_values >= self.terrain_levels["sand"]) & (elevation_values < self.terrain_levels["grass"])
        dirt_mask = (elevation_values >= self.terrain_levels["grass"]) & (elevation_values < self.terrain_levels["dirt"])
        mountain_mask = elevation_values >= self.terrain_levels["dirt"]

        if np.any(water_mask):
            t = (elevation_values[water_mask] / self.terrain_levels["water"])[..., np.newaxis]
            c1 = np.array(color_map["deep_water"])
            c2 = np.array(color_map["shallow_water"])
            colors[water_mask] = (1 - t) * c1 + t * c2
            
        colors[sand_mask] = color_map["sand"]
        colors[grass_mask] = color_map["grass"]
        colors[dirt_mask] = color_map["dirt"]
        colors[mountain_mask] = color_map["mountain"]
        
        return np.transpose(colors, (1, 0, 2))

    def _get_temperature_color_array(self, temp_values: np.ndarray) -> np.ndarray:
        """Converts an array of temperature data into an RGB color array using a LUT."""
        # Scale the [0, 1] float values to [0, 255] integer indices
        indices = (temp_values * 255).astype(np.uint8)
        # Use the indices to look up the pre-calculated colors
        colors = self._color_luts["temperature"][indices]
        return np.transpose(colors, (1, 0, 2))

    def _get_humidity_color_array(self, humidity_values: np.ndarray) -> np.ndarray:
        """Converts an array of humidity data into an RGB color array using a LUT."""
        indices = (humidity_values * 255).astype(np.uint8)
        colors = self._color_luts["humidity"][indices]
        return np.transpose(colors, (1, 0, 2))

    def _perform_chunk_generation(self, chunk_x: int, chunk_y: int, view_mode: str) -> pygame.Surface:
        """
        Performs the actual, CPU-intensive work of generating a chunk surface.
        This method is designed to be called by the background worker thread.
        """
        wx = np.linspace(chunk_x * self.chunk_size, (chunk_x + 1) * self.chunk_size, self.chunk_resolution)
        wy = np.linspace(chunk_y * self.chunk_size, (chunk_y + 1) * self.chunk_size, self.chunk_resolution)
        wx_grid, wy_grid = np.meshgrid(wx, wy)

        if view_mode == "terrain":
            data = self.generator.get_elevation(wx_grid, wy_grid)
            color_array = self._get_terrain_color_array(data)
        elif view_mode == "temperature":
            data = self.generator.get_temperature(wx_grid, wy_grid)
            color_array = self._get_temperature_color_array(data)
        else: # humidity
            data = self.generator.get_humidity(wx_grid, wy_grid)
            color_array = self._get_humidity_color_array(data)

        return pygame.surfarray.make_surface(color_array)

    def _chunk_generator_worker(self):
        """The target function for the background worker thread."""
        self.logger.info("Chunk generator worker thread started.")
        while not self.stop_event.is_set():
            try:
                # Wait for a request. Timeout allows the thread to check the stop_event.
                chunk_x, chunk_y, view_mode = self.generation_request_queue.get(timeout=0.1)
                
                # This is the same expensive logic as before, but on a background thread.
                surface = self._perform_chunk_generation(chunk_x, chunk_y, view_mode)
                
                # Put the result into the queue for the main thread to pick up.
                self.generation_result_queue.put(((chunk_x, chunk_y, view_mode), surface))

            except queue.Empty:
                continue # No requests, loop again.
        self.logger.info("Chunk generator worker thread stopped.")

    def _process_completed_chunks(self):
        """Checks the results queue and populates the cache. Runs on the main thread."""
        while not self.generation_result_queue.empty():
            (chunk_x, chunk_y, view_mode), surface = self.generation_result_queue.get()
            chunk_key = (chunk_x, chunk_y)
            self.chunk_surface_cache[view_mode][chunk_key] = surface
            # Remove from pending requests once it's in the cache
            if (chunk_x, chunk_y, view_mode) in self.pending_requests:
                self.pending_requests.remove((chunk_x, chunk_y, view_mode))

    def _request_chunk_surface(self, chunk_x: int, chunk_y: int, view_mode: str):
        """Adds a request to the generation queue if not already pending."""
        request_key = (chunk_x, chunk_y, view_mode)
        if request_key not in self.pending_requests:
            self.pending_requests.add(request_key)
            self.generation_request_queue.put(request_key)

    def shutdown(self):
        """Signals the worker thread to stop and waits for it to exit."""
        self.logger.info("Shutting down renderer worker thread...")
        self.stop_event.set()
        self.worker_thread.join()
        self.logger.info("Worker thread joined.")

    def _generate_placeholder_surface(self, chunk_x: int, chunk_y: int, view_mode: str) -> pygame.Surface:
        """
        Generates a very low-resolution placeholder surface synchronously.
        This is designed to be fast enough to run on the main thread without stuttering.
        """
        wx = np.linspace(chunk_x * self.chunk_size, (chunk_x + 1) * self.chunk_size, self.placeholder_resolution)
        wy = np.linspace(chunk_y * self.chunk_size, (chunk_y + 1) * self.chunk_size, self.placeholder_resolution)
        wx_grid, wy_grid = np.meshgrid(wx, wy)

        if view_mode == "terrain":
            data = self.generator.get_elevation(wx_grid, wy_grid)
            color_array = self._get_terrain_color_array(data)
        elif view_mode == "temperature":
            data = self.generator.get_temperature(wx_grid, wy_grid)
            color_array = self._get_temperature_color_array(data)
        else: # humidity
            data = self.generator.get_humidity(wx_grid, wy_grid)
            color_array = self._get_humidity_color_array(data)

        surface = pygame.surfarray.make_surface(color_array)
        # Cache the result so we only generate this once
        self.placeholder_cache[view_mode][(chunk_x, chunk_y)] = surface
        return surface

    def get_visible_chunks(self, camera, buffer: int = 0) -> list:
        """Helper to calculate visible chunks, with an optional buffer."""
        # Calculate the world coordinates for the corners of the buffered view
        top_left_wx, top_left_wy = camera.screen_to_world(-buffer * self.chunk_size, -buffer * self.chunk_size)
        bottom_right_wx, bottom_right_wy = camera.screen_to_world(
            camera.screen_width + buffer * self.chunk_size, 
            camera.screen_height + buffer * self.chunk_size
        )
        
        start_x = int(top_left_wx // self.chunk_size)
        end_x = int(bottom_right_wx // self.chunk_size)
        start_y = int(top_left_wy // self.chunk_size)
        end_y = int(bottom_right_wy // self.chunk_size)
        
        return [(cx, cy) for cx in range(start_x, end_x + 1) for cy in range(start_y, end_y + 1)]

    def prepare_entire_world(self):
        """
        Generator that prepares placeholders for ALL view modes, yielding progress.
        This allows the UI to draw an accurate, multi-stage loading bar.
        """
        world_width = self.generator.settings['world_width_chunks']
        world_height = self.generator.settings['world_height_chunks']
        
        view_modes_to_prepare = list(self.color_maps.keys())
        num_stages = len(view_modes_to_prepare)
        total_chunks_per_stage = world_width * world_height
        
        if total_chunks_per_stage == 0:
            yield 100.0, "Preparation complete"
            return

        for i, view_mode in enumerate(view_modes_to_prepare):
            status_message = f"Preparing {view_mode} maps..."
            
            # Skip if this view mode has already been fully cached
            if len(self.placeholder_cache[view_mode]) == total_chunks_per_stage:
                # Yield progress for this completed stage
                for j in range(total_chunks_per_stage):
                    overall_progress = ((i * total_chunks_per_stage + j + 1) / (num_stages * total_chunks_per_stage)) * 100
                    yield overall_progress, status_message
                continue

            for cy in range(world_height):
                for cx in range(world_width):
                    chunk_key = (cx, cy)
                    if chunk_key not in self.placeholder_cache[view_mode]:
                        surface = self._generate_placeholder_surface(cx, cy, view_mode)
                        self.placeholder_cache[view_mode][chunk_key] = surface
                    
                    # Calculate and yield overall progress
                    chunks_done_this_stage = (cy * world_width) + cx
                    chunks_done_previous_stages = i * total_chunks_per_stage
                    total_chunks_done = chunks_done_previous_stages + chunks_done_this_stage
                    total_work = num_stages * total_chunks_per_stage
                    
                    overall_progress = (total_chunks_done / total_work) * 100
                    yield overall_progress, status_message

    def draw(self, screen: pygame.Surface, camera, view_mode: str, high_res_zoom_threshold: float):
        """Draws the visible world and intelligently pre-caches chunks."""
        self._process_completed_chunks()
        screen.fill((10, 0, 20))

        world_width = self.generator.settings['world_width_chunks']
        world_height = self.generator.settings['world_height_chunks']

        # --- 1. Smart Pre-caching: Only request high-res chunks when zoomed in ---
        if camera.zoom >= high_res_zoom_threshold:
            chunks_to_request = self.get_visible_chunks(camera, buffer=2)
            for cx, cy in chunks_to_request:
                if 0 <= cx < world_width and 0 <= cy < world_height:
                    self._request_chunk_surface(cx, cy, view_mode)

        # --- 2. Draw: Render only the chunks currently on screen ---
        visible_chunks = self.get_visible_chunks(camera, buffer=0)
        high_res_cache = self.chunk_surface_cache[view_mode]
        placeholder_cache = self.placeholder_cache[view_mode]

        for cx, cy in visible_chunks:
            if not (0 <= cx < world_width and 0 <= cy < world_height):
                continue

            chunk_key = (cx, cy)
            # Use the high-res version if available, otherwise fall back to the placeholder.
            surface_to_draw = high_res_cache.get(chunk_key) or placeholder_cache.get(chunk_key)

            if surface_to_draw is None:
                # This is a safety net. Due to the initial load and pre-caching,
                # this should almost never be needed during gameplay.
                surface_to_draw = self._generate_placeholder_surface(cx, cy, view_mode)
                placeholder_cache[chunk_key] = surface_to_draw
            
            # --- Scaling and Drawing Logic (Unchanged) ---
            scaled_size = int(self.chunk_size * camera.zoom) + 2
            if scaled_size < 1:
                continue

            # Invalidate the scaled surface cache if zoom OR view mode has changed.
            if camera.zoom != self._last_camera_zoom or view_mode != self._last_view_mode:
                self.scaled_surface_cache.clear()
                self._last_camera_zoom = camera.zoom
                self._last_view_mode = view_mode

            scaled_surface = self.scaled_surface_cache.get(chunk_key)
            if scaled_surface is None:
                scaled_surface = pygame.transform.scale(surface_to_draw, (scaled_size, scaled_size))
                self.scaled_surface_cache[chunk_key] = scaled_surface

            chunk_screen_pos = camera.world_to_screen(cx * self.chunk_size, cy * self.chunk_size)
            screen.blit(scaled_surface, chunk_screen_pos)