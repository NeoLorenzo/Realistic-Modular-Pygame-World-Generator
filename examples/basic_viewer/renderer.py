# world_generator/renderer.py

"""
================================================================================
PYGAME WORLD RENDERER
================================================================================
This module provides a class to render the world data generated by the
WorldGenerator onto a Pygame surface.

Data Contract:
---------------
- Inputs (on initialization):
    - logger: A configured Python logging object.
- Inputs (on draw call):
    - screen (pygame.Surface): The target surface to draw on.
    - camera (Camera): An object that handles view transformations.
- Outputs: None.
- Side Effects: Draws pixels to the provided Pygame surface.
- Invariants: The visual output is a deterministic function of the generator's
  data and the camera's state.
================================================================================
"""

import pygame
import logging
import numpy as np

# Import the generator directly as it will be instantiated on-demand.
from world_generator.generator import WorldGenerator
# Import the generator's default config to access simulation-wide constants.
from world_generator import config as DEFAULTS
# Import the new shared color mapping utility
from world_generator import color_maps

# --- Default Color Mappings ---
# These are used by the renderer if no other color map is provided.
# Format: (R, G, B)
COLOR_MAP_TERRAIN = {
    "deep_water": (0, 0, 50),
    "shallow_water": (26, 102, 255),
    "sand": (240, 230, 140),
    "grass": (34, 139, 34),
    "dirt": (139, 69, 19),
    "mountain": (112, 128, 144)
}

COLOR_MAP_TEMPERATURE = {
    "coldest": (0, 0, 100),
    "cold": (0, 0, 255),
    "temperate": (255, 255, 0),
    "hot": (255, 0, 0),
    "hottest": (150, 0, 0)
}

COLOR_MAP_HUMIDITY = {
    "dry": (210, 180, 140),
    "wet": (70, 130, 180)
}


class WorldRenderer:
    """
    Handles the visualization of the world data on a Pygame screen.
    """
    def __init__(self, logger: logging.Logger):
        """
        Initializes the renderer for Live Preview Mode.
        """
        self.logger = logger
        self.logger.info("WorldRenderer initializing in Live Preview mode...")

        # --- Color Lookup Table (LUT) Generation (Rule 11) ---
        # LUTs are now created using the shared utility functions.
        self._color_luts = {
            "temperature": color_maps.create_temperature_lut(),
            "humidity": color_maps.create_humidity_lut()
        }
        
        # --- Load Real-World Unit Bounds for Normalization (Rule 3) ---
        self.min_temp_c = DEFAULTS.MIN_GLOBAL_TEMP_C
        self.max_temp_c = DEFAULTS.MAX_GLOBAL_TEMP_C
        self.temp_range_c = self.max_temp_c - self.min_temp_c
        if self.temp_range_c <= 0:
            self.logger.warning("Temperature range is zero or negative. Visualization may be incorrect.")
            self.temp_range_c = 1.0 # Avoid division by zero

        self.min_humidity_g_m3 = DEFAULTS.MIN_ABSOLUTE_HUMIDITY_G_M3
        self.max_humidity_g_m3 = DEFAULTS.MAX_ABSOLUTE_HUMIDITY_G_M3
        self.humidity_range_g_m3 = self.max_humidity_g_m3 - self.min_humidity_g_m3
        if self.humidity_range_g_m3 <= 0:
            self.logger.warning("Humidity range is zero or negative. Visualization may be incorrect.")
            self.humidity_range_g_m3 = 1.0 # Avoid division by zero

        self.logger.info("WorldRenderer initialized for on-demand preview generation.")

    def _create_temperature_lut(self) -> np.ndarray:
        """Creates a 256-entry color LUT for the temperature map."""
        # Create an array of 256 values from 0.0 to 1.0
        t = np.linspace(0.0, 1.0, 256)[..., np.newaxis]
        color_map = self.color_maps["temperature"]
        
        # Apply the same np.select logic as before, but only once on the 256 values
        colors = np.select(
            [t < self.temp_levels["cold"], t < self.temp_levels["temperate"], t < self.temp_levels["hot"]],
            [
                (1 - t/self.temp_levels["cold"]) * np.array(color_map["coldest"]) + (t/self.temp_levels["cold"]) * np.array(color_map["cold"]),
                (1 - (t-self.temp_levels["cold"])/(self.temp_levels["temperate"]-self.temp_levels["cold"])) * np.array(color_map["cold"]) + ((t-self.temp_levels["cold"])/(self.temp_levels["temperate"]-self.temp_levels["cold"])) * np.array(color_map["temperate"]),
                (1 - (t-self.temp_levels["temperate"])/(self.temp_levels["hot"]-self.temp_levels["temperate"])) * np.array(color_map["temperate"]) + ((t-self.temp_levels["temperate"])/(self.temp_levels["hot"]-self.temp_levels["temperate"])) * np.array(color_map["hot"])
            ],
            default=(1 - (t-self.temp_levels["hot"])/(1.0-self.temp_levels["hot"])) * np.array(color_map["hot"]) + ((t-self.temp_levels["hot"])/(1.0-self.temp_levels["hot"])) * np.array(color_map["hottest"])
        )
        return colors.astype(np.uint8)

    def _create_humidity_lut(self) -> np.ndarray:
        """Creates a 256-entry color LUT for the humidity map."""
        t = np.linspace(0.0, 1.0, 256)[..., np.newaxis]
        color_map = self.color_maps["humidity"]
        colors = (1 - t) * np.array(color_map["dry"]) + t * np.array(color_map["wet"])
        return colors.astype(np.uint8)

    def _get_terrain_color_array(self, elevation_values: np.ndarray) -> np.ndarray:
        """
        Converts an array of elevation data into an RGB color array using a
        highly optimized lookup table approach with np.digitize.
        """
        color_map = self.color_maps["terrain"]
        levels = self.terrain_levels

        # 1. Define the elevation boundaries (bins) for categorization.
        bins = [
            levels["water"],
            levels["sand"],
            levels["grass"],
            levels["dirt"]
        ]

        # 2. Define a corresponding color lookup table. The order MUST match the bins.
        #    We use shallow_water as the default for the water bin (index 0).
        color_lookup = np.array([
            color_map["shallow_water"],
            color_map["sand"],
            color_map["grass"],
            color_map["dirt"],
            color_map["mountain"]  # The color for values > the last bin.
        ], dtype=np.uint8)

        # 3. Use np.digitize to create an array of indices (0, 1, 2, 3, 4).
        #    This is extremely fast and replaces all boolean masking.
        indices = np.digitize(elevation_values, bins=bins)

        # 4. Use the indices to create the color array in a single, fast operation.
        colors = color_lookup[indices]

        # 5. Handle the special-case water gradient separately.
        #    This is still much faster as it only operates on a small subset of data.
        water_mask = indices == 0
        if np.any(water_mask):
            # Calculate the interpolation factor 't' only for water pixels.
            t = (elevation_values[water_mask] / levels["water"])[..., np.newaxis]
            c1 = np.array(color_map["deep_water"])
            c2 = np.array(color_map["shallow_water"])
            # Apply the gradient and update the colors array in place.
            colors[water_mask] = ((1 - t) * c1 + t * c2).astype(np.uint8)

        return np.transpose(colors, (1, 0, 2))

    def _get_temperature_color_array(self, temp_values: np.ndarray) -> np.ndarray:
        """
        Converts an array of Celsius temperature data into an RGB color array.
        It first normalizes the Celsius values to the [0, 1] range.
        """
        # 1. Normalize the incoming Celsius data to the [0, 1] range.
        normalized_temp = (temp_values - self.min_temp_c) / self.temp_range_c
        
        # 2. Scale the normalized [0, 1] float values to [0, 255] integer indices for the LUT.
        indices = (normalized_temp * 255).astype(np.uint8)
        
        # 3. Use the indices to look up the pre-calculated colors.
        colors = self._color_luts["temperature"][indices]
        return np.transpose(colors, (1, 0, 2))

    def _get_humidity_color_array(self, humidity_values: np.ndarray) -> np.ndarray:
        """
        Converts an array of absolute humidity data (g/m³) into an RGB color array.
        It first normalizes the g/m³ values to the [0, 1] range.
        """
        # 1. Normalize the incoming g/m³ data to the [0, 1] range.
        normalized_humidity = (humidity_values - self.min_humidity_g_m3) / self.humidity_range_g_m3

        # 2. Scale the normalized [0, 1] float values to [0, 255] integer indices for the LUT.
        indices = (normalized_humidity * 255).astype(np.uint8)

        # 3. Use the indices to look up the pre-calculated colors.
        colors = self._color_luts["humidity"][indices]
        return np.transpose(colors, (1, 0, 2))

    # --- All methods related to chunking and async generation have been removed ---

    def create_surface_from_color_array(self, color_array: np.ndarray) -> pygame.Surface:
        """
        Converts a NumPy color array into a Pygame surface.
        This is now the renderer's single responsibility for previews.
        """
        # The check for None is removed as the Application is now responsible
        # for ensuring a valid color_array is always passed.
        return pygame.surfarray.make_surface(color_array)

    def draw_live_preview(self, screen: pygame.Surface, camera, preview_surface: pygame.Surface):
        """
        Draws the pre-generated live preview surface to the screen, scaling
        it according to the camera's pan and zoom. This is a fast operation.
        """
        screen.fill((10, 0, 20))
        if preview_surface is None:
            return # Don't draw if the surface hasn't been generated yet.

        # 1. Calculate the scaled size of the entire world based on camera zoom.
        #    Ensure size is at least 1x1 pixel to avoid errors.
        scaled_width = max(1, int(camera.world_width * camera.zoom))
        scaled_height = max(1, int(camera.world_height * camera.zoom))

        # 2. Scale the preview surface to the calculated size.
        #    For performance, this could be cached, but we will address that later if needed.
        scaled_surface = pygame.transform.scale(preview_surface, (scaled_width, scaled_height))

        # 3. Get the on-screen position of the world's top-left corner (0, 0).
        top_left_pos = camera.world_to_screen(0, 0)

        # 4. Blit the scaled world surface to the screen.
        screen.blit(scaled_surface, top_left_pos)